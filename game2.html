<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pastel Co-op Tetris</title>
    <link rel="apple-touch-icon" href="icon.png">
    <link rel="icon" href="icon.png">
    <link rel="manifest" href="manifest.json">
    <style>
        body { 
            font-family: 'Apple SD Gothic Neo', sans-serif; 
            background-color: #fff5f5; color: #555; margin: 0; 
            display: flex; flex-direction: column; align-items: center; 
            height: 100dvh; overflow: hidden; touch-action: none; 
        }
        
        .main-wrapper { 
            display: flex; flex-direction: column; align-items: center; 
            width: 100%; max-width: 450px; height: 100%; position: relative; 
            justify-content: space-between; padding-bottom: 20px; box-sizing: border-box;
        }

        /* í—¤ë” */
        .header { 
            width: 90%; display: flex; justify-content: space-between; align-items: center; 
            margin-top: 15px; padding: 10px 20px; 
            background: white; border-radius: 20px; 
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.15); 
            flex-shrink: 0; box-sizing: border-box;
        }
        .score-box { text-align: center; }
        .label { font-size: 11px; color: #aaa; font-weight: bold; letter-spacing: 1px; }
        .value { font-size: 20px; font-weight: bold; color: #ff6b6b; }
        .diff-badge { font-size: 10px; padding: 2px 6px; border-radius: 8px; color: white; margin-bottom: 2px; display: inline-block; }
        .badge-easy { background: #4caf50; }
        .badge-hard { background: #f44336; }
        
        .pause-btn { background: none; border: none; font-size: 24px; cursor: pointer; color: #ff6b6b; padding: 0 10px; }

        /* í„´ í‘œì‹œê¸° */
        #turn-indicator { 
            width: 90%; text-align: center; padding: 8px; 
            font-weight: bold; font-size: 15px; 
            margin: 10px 0; border-radius: 15px; 
            transition: 0.3s; flex-shrink: 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .my-turn { background: #ff6b6b !important; color: white; transform: scale(1.02); }
        .other-turn { background: #eee !important; color: #888; }

        /* ê²Œì„ ë³´ë“œ ë°°ê²½ ë³€ê²½ (ê°€ì‹œì„±) */
        #game-container {
            flex: 1; display: flex; justify-content: center; align-items: center;
            width: 100%; overflow: hidden; margin: 5px 0;
        }
        #game-board { 
            background: #333; 
            border: 4px solid #ffccd5; border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            max-height: 100%; max-width: 90%; height: auto; width: auto;
            aspect-ratio: 10/20; object-fit: contain;
        }

        /* ì»¨íŠ¸ë¡¤ëŸ¬ */
        .controls { display: flex; gap: 12px; width: 90%; justify-content: center; margin-bottom: 10px; flex-shrink: 0; }
        .d-pad { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
        .c-btn { 
            width: 55px; height: 55px; 
            background: white; border: 1px solid #ffccd5; 
            border-radius: 15px; color: #ff6b6b; 
            font-size: 22px; font-weight: bold; 
            box-shadow: 0 4px 0 #ffe0e6; 
            cursor: pointer; display: flex; align-items: center; justify-content: center; 
            transition: 0.1s;
        }
        .c-btn:active { transform: translateY(4px); box-shadow: 0 0 0 #ffe0e6; background: #fff0f0; }
        .btn-drop { background: #ffeb3b; color: #f57c00; border-color: #fbc02d; box-shadow: 0 4px 0 #f9a825; }
        .btn-rot { background: #ff6b6b; color: white; border-color: #ff5252; box-shadow: 0 4px 0 #d32f2f; width: 65px; height: 65px; border-radius: 50%; margin-left: 15px; }

        /* ì˜¤ë²„ë ˆì´ & ë©”ë‰´ */
        #overlay, #pause-menu, #solo-menu, #vote-screen { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(255,255,255,0.95); z-index: 100; display: flex; 
            justify-content: center; align-items: center; flex-direction: column; gap: 15px;
            backdrop-filter: blur(5px);
        }
        #pause-menu, #solo-menu, #vote-screen { display: none; }

        h2 { color: #ff6b6b; margin-bottom: 10px; font-size: 24px; letter-spacing: -1px; text-align: center; }
        .sub-text { font-size: 13px; color: #888; margin-bottom: 20px; text-align: center; }

        .mode-btn { 
            width: 240px; padding: 15px; border: none; border-radius: 30px; 
            font-size: 16px; font-weight: bold; cursor: pointer; transition: 0.2s; 
            display: flex; justify-content: center; align-items: center; gap: 8px;
        }
        .mode-btn:disabled { filter: grayscale(1); cursor: not-allowed; opacity: 0.7; }
        .btn-solo { background: #a5d8ff; color: #1c7ed6; box-shadow: 0 4px 0 #74c0fc; }
        .btn-multi { background: #ffc9c9; color: #e03131; box-shadow: 0 4px 0 #ffa8a8; }
        .btn-easy { background: #b2f2bb; color: #2b8a3e; box-shadow: 0 4px 0 #8ce99a; }
        .btn-hard { background: #ff8787; color: #c92a2a; box-shadow: 0 4px 0 #fa5252; }
        .btn-save { background: #ffe066; color: #e67700; box-shadow: 0 4px 0 #fcc419; }
        .btn-exit { background: #ced4da; color: #495057; box-shadow: 0 4px 0 #adb5bd; }
        .btn-resume { background: white; color: #555; border: 2px solid #eee; box-shadow: 0 4px 0 #ddd; }
        
        .mode-btn:active { transform: translateY(4px); box-shadow: none; }
        .btn-back { color: #aaa; margin-top: 10px; font-size: 13px; text-decoration: underline; cursor: pointer; background:none; border:none; }

        /* íˆ¬í‘œ í™”ë©´ ìŠ¤íƒ€ì¼ */
        .vote-box { background: white; padding: 20px; border-radius: 20px; width: 85%; box-shadow: 0 5px 15px rgba(0,0,0,0.05); }
        .vote-status { display: flex; justify-content: space-between; margin-bottom: 20px; }
        .player-status { display: flex; flex-direction: column; align-items: center; gap: 5px; width: 45%; }
        .p-icon { font-size: 24px; background: #eee; width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: 0.3s; }
        .p-vote { font-size: 12px; font-weight: bold; color: #888; }
        
        .voted-easy { color: #2b8a3e; border: 3px solid #b2f2bb; background: #ebfbee; transform: scale(1.1); }
        .voted-hard { color: #c92a2a; border: 3px solid #ff8787; background: #fff5f5; transform: scale(1.1); }
        
        .status-msg { text-align: center; color: #ff6b6b; font-weight: bold; margin-top: 10px; font-size: 14px; min-height: 20px;}
    </style>
</head>
<body>

    <div class="main-wrapper">
        <div class="header">
            <div class="score-box">
                <span id="diff-badge" class="diff-badge badge-easy">EASY</span>
                <div class="label">LEVEL</div>
                <div class="value" id="level">1</div>
            </div>
            <button class="pause-btn" onclick="openPauseMenu()">â¸ï¸</button>
            <div class="score-box">
                <div class="label">SCORE</div>
                <div class="value" id="score">0</div>
                <div class="next-goal" id="next-goal">Next: 500</div>
            </div>
        </div>

        <div id="turn-indicator">ê²Œì„ ì¤€ë¹„ ì¤‘...</div>

        <div id="game-container">
            <canvas id="game-board" width="240" height="480"></canvas>
        </div>

        <div class="controls">
            <div class="d-pad">
                <button class="c-btn" onclick="inputLeft()">â†</button>
                <button class="c-btn btn-drop" onclick="inputDrop()">â‡“</button>
                <button class="c-btn" onclick="inputRight()">â†’</button>
                <button class="c-btn" style="grid-column: 2; grid-row: 1;" onclick="inputRotate()">â†»</button>
            </div>
            <button class="c-btn btn-rot" onclick="inputHardDrop()">ğŸš€</button> 
        </div>

        <div id="overlay">
            <h2>ğŸ§© PASTEL TETRIS</h2>
            <button class="mode-btn btn-solo" onclick="checkSoloSave()"><span>ğŸ‘¤</span> í˜¼ì í•˜ê¸°</button>
            <button class="mode-btn btn-multi" onclick="startMulti()"><span>ğŸ‘¥</span> ê°™ì´ í•˜ê¸° (2ì¸)</button>
            <a href="gamelist.html" class="btn-back">ë‚˜ê°€ê¸°</a>
        </div>

        <div id="solo-menu">
            <h2 style="color:#74c0fc;">SOLO MODE</h2>
            <div id="has-save-msg" style="font-size:12px; color:#aaa; margin-bottom:10px; display:none;">ì €ì¥ëœ ê²Œì„ì´ ìˆì–´ìš”!</div>
            <button id="btn-resume-solo" class="mode-btn btn-resume" onclick="loadSoloGame()" style="display:none;">ì´ì–´í•˜ê¸°</button>
            <div style="width:100%; border-bottom:1px solid #eee; margin:10px 0;"></div>
            <div style="font-size:12px; color:#aaa;">ìƒˆ ê²Œì„ ë‚œì´ë„ ì„ íƒ</div>
            <button class="mode-btn btn-easy" onclick="startSoloNew('easy')">ğŸŒ± EASY (Lv.1)</button>
            <button class="mode-btn btn-hard" onclick="startSoloNew('hard')">ğŸ”¥ HARD (Lv.4)</button>
            <button class="btn-back" onclick="closeSoloMenu()">ì·¨ì†Œ</button>
        </div>

        <div id="vote-screen">
            <h2>ë‚œì´ë„ íˆ¬í‘œ</h2>
            <p class="sub-text">ë‘˜ ë‹¤ ê°™ì€ ë‚œì´ë„ë¥¼ ê³¨ë¼ì•¼ ì‹œì‘!</p>
            
            <div class="vote-box">
                <div class="vote-status">
                    <div class="player-status">
                        <div id="p1-icon" class="p-icon">ğŸ‘¤</div>
                        <span id="p1-vote-text" class="p-vote">ì ‘ì† ëŒ€ê¸°...</span>
                    </div>
                    <div class="player-status">
                        <div id="p2-icon" class="p-icon">ğŸ‘¤</div>
                        <span id="p2-vote-text" class="p-vote">ì ‘ì† ëŒ€ê¸°...</span>
                    </div>
                </div>
                <div class="status-msg" id="vote-msg">ìƒëŒ€ë°©ì„ ê¸°ë‹¤ë¦¬ê³  ìˆìŠµë‹ˆë‹¤...</div>
            </div>

            <button class="mode-btn btn-easy" onclick="voteDifficulty('easy')">ğŸŒ± EASY</button>
            <button class="mode-btn btn-hard" onclick="voteDifficulty('hard')">ğŸ”¥ HARD</button>
            <button class="btn-back" onclick="location.reload()">ë‚˜ê°€ê¸°</button>
        </div>

        <div id="pause-menu">
            <h2>PAUSED</h2>
            <button class="mode-btn btn-resume" onclick="resumeGame()">ê³„ì†í•˜ê¸°</button>
            <button class="mode-btn btn-save" id="btn-save-manual" onclick="saveAndAlert()">ì €ì¥í•˜ê¸°</button>
            <button class="mode-btn btn-exit" onclick="saveAndExit()">ì €ì¥ í›„ ë‚˜ê°€ê¸°</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, doc, onSnapshot, setDoc, updateDoc, getDoc } 
        from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        // ğŸ”´ [í•„ìˆ˜] ë³¸ì¸ì˜ firebaseConfig
    const firebaseConfig = {
      apiKey: "AIzaSyDTMfB6Fl6QiiJdcTjpcU9nha2GP4Ne_6o",
      authDomain: "lovechatproject-2db11.firebaseapp.com",
      projectId: "lovechatproject-2db11",
      storageBucket: "lovechatproject-2db11.firebasestorage.app",
      messagingSenderId: "1069136590072",
      appId: "1:1069136590072:web:7712e718db03c70bff370d",
      measurementId: "G-ERG2LL283F"
    };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const gameDocRef = doc(db, "games", "coop_tetris");

        let myId = localStorage.getItem('chat_uid');
        if(!myId) { myId = 'user_' + Date.now(); localStorage.setItem('chat_uid', myId); }

        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 24;
        const canvas = document.getElementById('game-board');
        const ctx = canvas.getContext('2d');
        
        let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
        let gameMode = null; 
        let myRole = null;
        let difficulty = 'easy'; 
        let currentTurn = 'p1';
        let isMyTurn = false;
        let score = 0;
        let level = 1;
        let gameOver = false;
        let isPaused = false;
        let dropInterval = 1000;
        let lastDropTime = 0;
        let activePiece = null;
        let animationId = null;

        // --- ğŸ¨ [ë¸”ë¡ ì •ì˜] ---
        const SHAPES = [
            [], 
            [[1, 1, 1, 1]], [[1, 1], [1, 1]], [[0, 1, 0], [1, 1, 1]], 
            [[1, 0, 0], [1, 1, 1]], [[0, 0, 1], [1, 1, 1]], 
            [[0, 1, 1], [1, 1, 0]], [[1, 1, 0], [0, 1, 1]],
            // 3~5ì¹¸ ê¸°ê´´
            [[1]], [[1, 1, 1]], [[1, 1], [1, 0]], [[1, 1, 1, 1, 1]], 
            [[0, 1, 0], [1, 1, 1], [0, 1, 0]],
            // ì–µê¹Œ ë¸”ë¡
            [[1, 0, 1], [1, 1, 1], [0, 1, 0]], 
            [[0, 1, 0], [1, 1, 1], [1, 0, 1]], 
            [[1, 1, 1, 1], [1, 0, 0, 0]], 
            [[1, 0, 1], [0, 1, 0], [1, 0, 1]], 
            [[1, 1, 1], [1, 0, 1], [1, 1, 1]], 
            [[1, 0, 0], [0, 1, 0], [0, 0, 1]]  
        ];

        const COLORS = [
            '#333333', 
            '#ffadad', '#ffd6a5', '#fdffb6', '#caffbf', '#9bf6ff', '#a0c4ff', '#bdb2ff',
            '#ffc6ff', '#fffffc', '#fabfb7', '#fdf2f0', '#b9fbc0',
            '#ff9aa2', '#e2f0cb', '#b5ead7', '#c7ceea', '#f4f1de', '#e07a5f'
        ];

        // ===========================================
        // ğŸ’¾ [ì†”ë¡œ ëª¨ë“œ ì‹œìŠ¤í…œ]
        // ===========================================
        window.checkSoloSave = () => {
            const saveData = localStorage.getItem('tetris_solo_save');
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('solo-menu').style.display = 'flex';
            
            if(saveData) {
                document.getElementById('has-save-msg').style.display = 'block';
                document.getElementById('btn-resume-solo').style.display = 'flex';
            } else {
                document.getElementById('has-save-msg').style.display = 'none';
                document.getElementById('btn-resume-solo').style.display = 'none';
            }
        };
        window.closeSoloMenu = () => { 
            document.getElementById('solo-menu').style.display = 'none'; 
            document.getElementById('overlay').style.display = 'flex';
        };
        
        window.startSoloNew = (diff) => {
            localStorage.removeItem('tetris_solo_save');
            gameMode = 'solo'; myRole = 'p1'; currentTurn = 'p1'; isMyTurn = true;
            difficulty = diff;
            
            document.getElementById('solo-menu').style.display = 'none';
            resetLocalBoard(); spawnPiece(); updateGameLoop();
        };

        window.loadSoloGame = () => {
            const saveStr = localStorage.getItem('tetris_solo_save');
            if(!saveStr) return startSoloNew('easy');
            const save = JSON.parse(saveStr);
            board = save.board; score = save.score; level = save.level; difficulty = save.difficulty || 'easy';
            gameMode = 'solo'; myRole = 'p1'; currentTurn = 'p1'; isMyTurn = true;
            
            updateScoreUI(); updateTurnUI();
            document.getElementById('solo-menu').style.display = 'none';
            spawnPiece(); updateGameLoop();
        };

        function saveGameToLocal() {
            if(gameMode !== 'solo') return;
            const data = { board: board, score: score, level: level, difficulty: difficulty, date: new Date().getTime() };
            localStorage.setItem('tetris_solo_save', JSON.stringify(data));
        }

        // ===========================================
        // â¯ï¸ [ì¼ì‹œì •ì§€]
        // ===========================================
        window.openPauseMenu = () => {
            if(gameOver) return;
            isPaused = true;
            if(animationId) cancelAnimationFrame(animationId);
            const saveBtn = document.getElementById('btn-save-manual');
            if(gameMode === 'multi') { saveBtn.innerText = "ë©€í‹°ëŠ” ìë™ì €ì¥ë¨"; saveBtn.disabled = true; saveBtn.style.opacity = "0.5"; } 
            else { saveBtn.innerText = "ì €ì¥í•˜ê¸°"; saveBtn.disabled = false; saveBtn.style.opacity = "1"; }
            document.getElementById('pause-menu').style.display = 'flex';
        };

        window.resumeGame = () => {
            isPaused = false;
            document.getElementById('pause-menu').style.display = 'none';
            lastDropTime = Date.now();
            updateGameLoop();
        };

        window.saveAndAlert = () => { if(gameMode === 'solo') { saveGameToLocal(); alert("ê²Œì„ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ’¾"); } };
        window.saveAndExit = () => { if(gameMode === 'solo') { saveGameToLocal(); } location.href = "gamelist.html"; };

        document.addEventListener('keydown', (e) => { if(e.keyCode === 27) { if(isPaused) resumeGame(); else openPauseMenu(); } });

        // ===========================================
        // ğŸ‘¥ [ë©€í‹°í”Œë ˆì´ íˆ¬í‘œ: í”½ìŠ¤ ë²„ì „]
        // ===========================================
        window.startMulti = async () => {
            gameMode = 'multi';
            const docSnap = await getDoc(gameDocRef);
            let data = docSnap.exists() ? docSnap.data() : null;

            // âš ï¸ [ì¤‘ìš”] ì´ì „ ë²„ì „ ë°ì´í„°(status: waiting ë“±)ê°€ ìˆìœ¼ë©´ ê°•ì œë¡œ 'voting'ìœ¼ë¡œ ì´ˆê¸°í™”
            const isInvalidState = !data || data.status === 'waiting' || (data.p1 && data.p2 && data.status !== 'voting' && data.status !== 'playing');
            
            const updatePayload = {};
            if (isInvalidState) {
                // ë°© ë¦¬ì…‹ ë° íˆ¬í‘œ ëª¨ë“œ ê°•ì œ ì „í™˜
                await setDoc(gameDocRef, {
                    p1: myId, p2: null, status: 'voting',
                    p1Vote: null, p2Vote: null,
                    boardStr: JSON.stringify(Array.from({length: ROWS}, () => Array(COLS).fill(0))),
                    turn: 'p1', score: 0, level: 1
                });
                myRole = 'p1';
            } else if (!data.p1) {
                updatePayload.p1 = myId; myRole = 'p1';
            } else if (!data.p2) {
                if (data.p1 === myId) { myRole = 'p1'; }
                else { updatePayload.p2 = myId; myRole = 'p2'; }
            }
            if(Object.keys(updatePayload).length > 0) await updateDoc(gameDocRef, updatePayload);

            document.getElementById('overlay').style.display = 'none';
            document.getElementById('vote-screen').style.display = 'flex';

            onSnapshot(gameDocRef, (snap) => {
                const d = snap.data();
                if (!d) return;

                // 1. íˆ¬í‘œ í™”ë©´ ì—…ë°ì´íŠ¸
                if (d.status === 'voting') {
                    updateVoteUI(d);
                    if (myRole === 'p1' && d.p1Vote && d.p2Vote && d.p1Vote === d.p2Vote) {
                        setTimeout(() => {
                            updateDoc(gameDocRef, { 
                                status: 'playing', 
                                difficulty: d.p1Vote,
                                level: d.p1Vote === 'hard' ? 4 : 1, 
                                score: 0
                            });
                        }, 1500);
                    }
                }

                // 2. ê²Œì„ ì‹œì‘
                if (d.status === 'playing') {
                    document.getElementById('vote-screen').style.display = 'none';
                    board = JSON.parse(d.boardStr);
                    score = d.score; level = d.level; currentTurn = d.turn;
                    difficulty = d.difficulty || 'easy';
                    
                    updateScoreUI(); isMyTurn = (currentTurn === myRole); updateTurnUI();

                    if (isMyTurn && !activePiece) {
                        spawnPiece(); lastDropTime = Date.now(); if (!animationId) updateGameLoop();
                    } else if (!isMyTurn) {
                        if (animationId) cancelAnimationFrame(animationId);
                        animationId = null; activePiece = null; draw(); 
                    }
                }
            });
        };

        window.voteDifficulty = async (vote) => {
            const field = myRole === 'p1' ? 'p1Vote' : 'p2Vote';
            await updateDoc(gameDocRef, { [field]: vote });
        };

        function updateVoteUI(data) {
            const p1Text = document.getElementById('p1-vote-text');
            const p2Text = document.getElementById('p2-vote-text');
            const p1Icon = document.getElementById('p1-icon');
            const p2Icon = document.getElementById('p2-icon');
            const msg = document.getElementById('vote-msg');

            // P1 UI Update
            if(!data.p1) { p1Text.innerText = "ëŒ€ê¸° ì¤‘..."; p1Icon.className = "p-icon"; }
            else if(!data.p1Vote) { p1Text.innerText = "ê³ ë¯¼ ì¤‘..."; p1Icon.className = "p-icon"; }
            else { p1Text.innerText = data.p1Vote.toUpperCase(); p1Icon.className = `p-icon voted-${data.p1Vote}`; }

            // P2 UI Update
            if(!data.p2) { p2Text.innerText = "ì ‘ì† ëŒ€ê¸°..."; p2Icon.className = "p-icon"; }
            else if(!data.p2Vote) { p2Text.innerText = "ê³ ë¯¼ ì¤‘..."; p2Icon.className = "p-icon"; }
            else { p2Text.innerText = data.p2Vote.toUpperCase(); p2Icon.className = `p-icon voted-${data.p2Vote}`; }

            if(data.p1Vote && data.p2Vote) {
                if(data.p1Vote === data.p2Vote) msg.innerText = "ì˜ê²¬ ì¼ì¹˜! ê³§ ì‹œì‘í•©ë‹ˆë‹¤...";
                else msg.innerText = "ì„œë¡œ ë‹¤ë¥¸ ë‚œì´ë„ë¥¼ ê³¨ëì–´ìš”!";
            } else {
                msg.innerText = "ë‚œì´ë„ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.";
            }
        }

        // ===========================================
        // ğŸ® [ê²Œì„ ë©”ì¸ ë¡œì§]
        // ===========================================
        
        function spawnPiece() {
            let minIndex = 1; let maxIndex = 7;

            if (difficulty === 'easy') {
                if (level >= 3 && level < 6) { maxIndex = 12; } 
                else if (level >= 6 && level < 9) { minIndex = 1; maxIndex = 16; } 
                else if (level >= 9) { minIndex = 8; maxIndex = SHAPES.length - 1; } 
            } else {
                // í•˜ë“œ ëª¨ë“œ: ì „ë©´ ê°œë°©
                minIndex = 1; 
                maxIndex = SHAPES.length - 1;
            }

            const typeId = Math.floor(Math.random() * (maxIndex - minIndex + 1)) + minIndex;
            const shape = SHAPES[typeId];
            
            activePiece = {
                x: Math.floor(COLS / 2) - Math.floor(shape[0].length / 2),
                y: 0,
                shape: shape,
                color: COLORS[typeId]
            };

            if (collision(0, 0, activePiece.shape)) {
                gameOver = true;
                alert("GAME OVER! ì ìˆ˜: " + score);
                if (gameMode === 'multi') { setDoc(gameDocRef, { p1: null, p2: null, status: 'waiting' }); }
                localStorage.removeItem('tetris_solo_save');
                location.reload();
            }
        }

        function collision(offsetX, offsetY, pieceShape) {
            for (let r = 0; r < pieceShape.length; r++) {
                for (let c = 0; c < pieceShape[r].length; c++) {
                    if (!pieceShape[r][c]) continue;
                    let newX = activePiece.x + c + offsetX;
                    let newY = activePiece.y + r + offsetY;
                    if (newX < 0 || newX >= COLS || newY >= ROWS) return true;
                    if (newY < 0) continue;
                    if (board[newY][newX]) return true;
                }
            }
            return false;
        }

        function lockPiece() {
            for (let r = 0; r < activePiece.shape.length; r++) {
                for (let c = 0; c < activePiece.shape[r].length; c++) {
                    if (!activePiece.shape[r][c]) continue;
                    let by = activePiece.y + r; let bx = activePiece.x + c;
                    if (by >= 0) board[by][bx] = activePiece.color;
                }
            }
            
            let linesCleared = 0;
            for (let r = 0; r < ROWS; r++) {
                if (board[r].every(cell => cell !== 0)) {
                    board.splice(r, 1); board.unshift(Array(COLS).fill(0)); linesCleared++;
                }
            }

            if (linesCleared > 0) {
                score += linesCleared * 100;
                
                // [ë‚œì´ë„ë³„ ë°¸ëŸ°ìŠ¤ ì¡°ì •]
                if (difficulty === 'hard') {
                    // í•˜ë“œ: ë ˆë²¨ì—… ê¸°ì¤€ ë‚®ìŒ(300ì ), ì†ë„ ë” ë¹ ë¦„(ê¸°ë³¸ 0.5ì´ˆ ì‹œì‘ -> 0.1ì´ˆê¹Œì§€)
                    level = 4 + Math.floor(score / 300);
                    dropInterval = Math.max(100, 500 - ((level - 4) * 60)); 
                } else {
                    // ì´ì§€: ë ˆë²¨ì—… ê¸°ì¤€ ë†’ìŒ(500ì ), ì†ë„ ë³´í†µ(ê¸°ë³¸ 1.0ì´ˆ ì‹œì‘)
                    level = 1 + Math.floor(score / 500);
                    dropInterval = Math.max(200, 1000 - (level * 80)); 
                }
            }
            activePiece = null; endTurn();
        }

        async function endTurn() {
            if (gameMode === 'solo') { updateScoreUI(); spawnPiece(); } 
            else {
                const nextTurn = currentTurn === 'p1' ? 'p2' : 'p1';
                isMyTurn = false; updateTurnUI();
                await updateDoc(gameDocRef, { boardStr: JSON.stringify(board), score: score, level: level, turn: nextTurn });
            }
        }

        function updateGameLoop() {
            if (isPaused) return;
            if (!isMyTurn && gameMode === 'multi') return;
            if (gameOver) return;
            const now = Date.now();
            if (now - lastDropTime > dropInterval) { movePiece(0, 1); lastDropTime = now; }
            draw();
            animationId = requestAnimationFrame(updateGameLoop);
        }

        function movePiece(dx, dy) {
            if (!activePiece) return;
            if (!collision(dx, dy, activePiece.shape)) { activePiece.x += dx; activePiece.y += dy; } 
            else if (dy > 0) { lockPiece(); }
        }

        function rotatePiece() {
            if (!activePiece) return;
            const matrix = activePiece.shape;
            const N = matrix.length; const M = matrix[0].length;
            let result = Array.from({length: M}, () => Array(N).fill(0));
            for (let i = 0; i < N; i++) { for (let j = 0; j < M; j++) { result[j][N - 1 - i] = matrix[i][j]; } }
            if (!collision(0, 0, result)) { activePiece.shape = result; } 
            else { if (!collision(-1, 0, result)) { activePiece.x -= 1; activePiece.shape = result; } else if (!collision(1, 0, result)) { activePiece.x += 1; activePiece.shape = result; } }
        }

        function draw() {
            ctx.fillStyle = '#333'; // ì§„í•œ íšŒìƒ‰ ë°°ê²½ (ê°€ì‹œì„±)
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ê²©ì (ì€ì€í•˜ê²Œ)
            ctx.strokeStyle = '#444'; ctx.lineWidth = 1;
            for(let x=0; x<=COLS; x++) { ctx.beginPath(); ctx.moveTo(x*BLOCK_SIZE, 0); ctx.lineTo(x*BLOCK_SIZE, ROWS*BLOCK_SIZE); ctx.stroke(); }
            for(let y=0; y<=ROWS; y++) { ctx.beginPath(); ctx.moveTo(0, y*BLOCK_SIZE); ctx.lineTo(COLS*BLOCK_SIZE, y*BLOCK_SIZE); ctx.stroke(); }

            for (let r = 0; r < ROWS; r++) { for (let c = 0; c < COLS; c++) { if (board[r][c]) { drawBlock(c, r, board[r][c]); } } }

            if (activePiece) {
                let ghostY = activePiece.y;
                while (!collision(0, ghostY - activePiece.y + 1, activePiece.shape)) { ghostY++; }
                ctx.globalAlpha = 0.2;
                for (let r = 0; r < activePiece.shape.length; r++) { for (let c = 0; c < activePiece.shape[r].length; c++) { if (activePiece.shape[r][c]) { drawBlock(activePiece.x + c, ghostY + r, activePiece.color); } } }
                ctx.globalAlpha = 1.0; 
                for (let r = 0; r < activePiece.shape.length; r++) { for (let c = 0; c < activePiece.shape[r].length; c++) { if (activePiece.shape[r][c]) { drawBlock(activePiece.x + c, activePiece.y + r, activePiece.color); } } }
            }
        }

        function drawBlock(x, y, color) {
            ctx.fillStyle = color; ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            ctx.fillStyle = 'rgba(255,255,255,0.4)'; ctx.beginPath(); ctx.arc(x * BLOCK_SIZE + 6, y * BLOCK_SIZE + 6, 2, 0, Math.PI * 2); ctx.fill();
        }

        function updateTurnUI() {
            const ind = document.getElementById('turn-indicator');
            if (gameMode === 'solo') { ind.innerText = "SOLO MODE"; ind.className = 'my-turn'; } 
            else {
                if (isMyTurn) { ind.innerText = "ğŸ‘‰ ë‹¹ì‹  ì°¨ë¡€! (MOVE!)"; ind.className = 'my-turn'; } 
                else { ind.innerText = "âœ‹ ìƒëŒ€ë°© ì°¨ë¡€ (WAIT)"; ind.className = 'other-turn'; }
            }
        }

        function updateScoreUI() {
            document.getElementById('score').innerText = score;
            document.getElementById('level').innerText = level;
            const threshold = difficulty === 'hard' ? 300 : 500;
            const nextLevelScore = (level - (difficulty==='hard'?3:0)) * threshold;
            document.getElementById('next-goal').innerText = `Next: ${Math.max(0, nextLevelScore - score)}`;
            
            const badge = document.getElementById('diff-badge');
            badge.innerText = difficulty.toUpperCase();
            badge.className = `diff-badge badge-${difficulty}`;
        }

        function resetLocalBoard() {
            board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
            score = 0;
            
            // [ë‚œì´ë„ë³„ ì´ˆê¸° ì„¤ì •]
            if (difficulty === 'hard') {
                level = 4;
                dropInterval = 500; // í•˜ë“œ: 0.5ì´ˆ ì‹œì‘
            } else {
                level = 1;
                dropInterval = 1000; // ì´ì§€: 1.0ì´ˆ ì‹œì‘
            }
            updateScoreUI();
        }

        window.inputLeft = () => { if(isMyTurn && !isPaused) movePiece(-1, 0); };
        window.inputRight = () => { if(isMyTurn && !isPaused) movePiece(1, 0); };
        window.inputDrop = () => { if(isMyTurn && !isPaused) movePiece(0, 1); }; 
        window.inputRotate = () => { if(isMyTurn && !isPaused) rotatePiece(); };
        window.inputHardDrop = () => { 
            if(!isMyTurn || !activePiece || isPaused) return;
            let dist = 0; while (!collision(0, dist + 1, activePiece.shape)) { dist++; }
            activePiece.y += dist; draw(); lockPiece(); 
        };

        window.openPauseMenu = () => {
            if(gameOver) return;
            isPaused = true;
            if(animationId) cancelAnimationFrame(animationId);
            const saveBtn = document.getElementById('btn-save-manual');
            if(gameMode === 'multi') { saveBtn.innerText = "ë©€í‹°ëŠ” ìë™ì €ì¥ë¨"; saveBtn.disabled = true; saveBtn.style.opacity = "0.5"; } 
            else { saveBtn.innerText = "ì €ì¥í•˜ê¸°"; saveBtn.disabled = false; saveBtn.style.opacity = "1"; }
            document.getElementById('pause-menu').style.display = 'flex';
        };

        window.resumeGame = () => {
            isPaused = false;
            document.getElementById('pause-menu').style.display = 'none';
            lastDropTime = Date.now();
            updateGameLoop();
        };

        window.saveAndAlert = () => { if(gameMode === 'solo') { saveGameToLocal(); alert("ê²Œì„ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ’¾"); } };
        window.saveAndExit = () => { if(gameMode === 'solo') { saveGameToLocal(); } location.href = "gamelist.html"; };

        document.addEventListener('keydown', (e) => {
            if (!isMyTurn || isPaused) return;
            if (e.keyCode === 37) inputLeft();
            else if (e.keyCode === 39) inputRight();
            else if (e.keyCode === 40) inputDrop();
            else if (e.keyCode === 38) inputRotate();
            else if (e.keyCode === 32) { e.preventDefault(); inputHardDrop(); }
            else if (e.keyCode === 27) openPauseMenu();
        });
    </script>
</body>
</html>